#include "stdafx.h"
#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <iostream>
#include <Windows.h>
#include <sstream>
#include <cstring>
#include <fstream>
#include <iostream>
using namespace sf;
using namespace std;
class gamesound;
class PLAYER;
struct  Enemy;
struct Flash;
int gravity(string ** ,int,int, int,int,gamesound&,gamesound&);
int string_to_int(string );
string int_to_string(int );

string** start(int number_level,int *H_,int *W_, int *win_);
float offsetX=0, offsetY=0;
void delete_map(string**TileMap,int*H, Enemy *cube, Enemy *stars,int qantity_cube,int qantity_stars);
void show (RenderWindow&,Sprite &,string** TileMap, int *H,int *W,Flash flash, Enemy *cube,int qantity_cube, Enemy stars,int qantity_stars );
void set_player(RenderWindow& window,Sprite &sprite, PLAYER& player,string ** TileMap,int *H, int *W,int time, gamesound & sound);
Enemy* create_enemy(string** Tilemap,int H,int W, int *quantity,char name_enemy);
bool move_enemy(string** TileMap,Enemy* enemy,int quantity,char name_enemy,PLAYER player);
//*******************************************************************************************************************************
struct Flash{
	Flash():diamant_flash(0),cube_flash(0),star_flash(0)
	{};
	int diamant_flash;
	int cube_flash;
	int star_flash;
};

//********************************************************************************************************************************
class gamesound{
public:
	SoundBuffer sound_bufer;
	Sound sound;
	string filename;
	gamesound (string filename_){
		filename=filename_;
		sound_bufer.loadFromFile(filename);//загружаем в него звук
		sound.setBuffer (sound_bufer); //создаем звук и загружаем в него звук из буфера

	}
	void play(){
		sound.play();
	}
};

//******************************************************************************************************************************
struct Enemy{
	Enemy():x(0),y(0),step(1),live(1),symbol('-')
	{};
	int x,y,step,live;
	char symbol;
};
//****************************************************************************************************************************
class PLAYER {

public:

	float dx,dy;    //перемещение вверх и низ
	FloatRect rect; //координаты и размер спрайта
	Sprite sprite;
	float currentFrame; // смена спрайта
	int diamant;         // количество собранных алмазов
	string**TileMap;     //основная карта
	int live;
	SoundBuffer sound_bufer;
	Sound almaz;
	PLAYER(Texture &image,string **t)
	{
		sprite.setTexture(image);
		sprite.setTextureRect(IntRect(16,0,16,16));
		rect = FloatRect(1*16,1*16,16,16);
		diamant=0;
		dx=dy=0;
		currentFrame = 0;
		TileMap=t;
		live=1;

		sound_bufer.loadFromFile("sound/almaz.wav");//загружаем в него звук

		almaz.setBuffer(sound_bufer) ;
	}

	void update(float time)    
	{	

		Collision();   //проверка на столкновение

		rect.left += dx ;	

		rect.top += dy ;

		if (currentFrame > 6) currentFrame -=6 ; //смена спрайта двмженмя

		if (dx>0)sprite.setTextureRect(IntRect(16*int(currentFrame),32,16,16));

		if (dx<0) sprite.setTextureRect(IntRect(16*int(currentFrame)+16,32,-16,16));

		if (dy>0)sprite.setTextureRect(IntRect(16*int(currentFrame),0,16,16));

		if (dy<0) sprite.setTextureRect(IntRect(32,0,16,16));

		for (int i=0;i<10;i++){Sleep(time);}// задержка в игре
		currentFrame++;
		sprite.setPosition(rect.left-offsetX, rect.top-offsetY); // установка игрока на поле

		dx=0;
		dy=0;
	}

	void Collision()
	{   
		int i = (rect.top)/16;
		int j =(rect.left)/16;
		if (dx>0&& (TileMap[i][j+1]=='R'&&TileMap[i][j+2]==' '))  {TileMap[i][j+2]='R';TileMap[i][j]=' ';TileMap[i][j+1]='-';  return;}
		if (dx<0&& (TileMap[i][j-1]=='R'&&TileMap[i][j-2]==' '))  {TileMap[i][j-2]='R';TileMap[i][j]=' ';TileMap[i][j-1]='-';  return;}
		if (dx>0&& (TileMap[i][j+1]=='W'||TileMap[i][j+1]=='H'||TileMap[i][j+1]=='R'))  {dx=0;return;}  //проверка на столкновение
		if (dx<0&& (TileMap[i][j-1]=='W'||TileMap[i][j-1]=='H'||TileMap[i][j-1]=='R')) {dx=0;return;}
		if (dy>0&& (TileMap[i+1][j]=='W'||TileMap[i+1][j]=='H'||TileMap[i+1][j]=='R')) {dy=0;return;} 
		if (dy<0&& (TileMap[i-1][j]=='W'||TileMap[i-1][j]=='H'||TileMap[i-1][j]=='R')) { dy=0;return;}

		if (TileMap[i][j]=='D') 
		{    
			diamant+=1;// собираем кристал
			TileMap[i][j]='-';
			almaz.play();
		}

  
		if((dx+dy)!=0)TileMap[i][j]=' ';					
		}
	
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _tmain(int argc, _TCHAR* argv[])
{
// 	SetConsoleCP(1251);
// 	SetConsoleOutputCP(1251);
// 	setlocale(LC_ALL, "Russian");


	 gamesound sound_step1("sound/step1.wav");
	 gamesound sound_step2("sound/step2.wav");
	 gamesound sound_stone("sound/stone.wav");
	 gamesound sound_stone_left("sound/stone_left.wav");
     gamesound sound_life("sound/life2.wav");
	 gamesound sound_almaz("sound/almaz.wav");
	 gamesound start_door("sound/start_door.wav");
	 gamesound door("sound/door.wav");
	 
	 int time=10,H,W,i,j,win,max_level; //скорость игры,размер игрового поля, количество алмазов для следующего уровня, максимальное количество карт
	                                    // устанавливается в start
	 int number_level=1;
	 bool gameover(false);
	 bool flag_win=false;
     bool rockfall=false; //пропуск первой проверки камней
	 int quantity_cube;
	 int quantity_stars;
	 Flash flash;
	 int pldy=0;// двигался игрок или нет
	 bool button_no_press = true;
	 int kill= 0;
	 string **TileMap=start(number_level,&H,&W,&win);
	 

     Enemy *cube= create_enemy(TileMap,H,W,&quantity_cube,'C');
     Enemy *stars= create_enemy(TileMap,H,W,&quantity_stars,'X');
	 RenderWindow window( VideoMode(400, 225), "boulder dash");
	
  	Texture texture;
	 texture.loadFromFile("fang.png");

	Sprite sprite_map(texture);

	float currentFrame=0;
    PLAYER mario(texture,TileMap);
    
 std::ifstream  fil("game.cfg"); 
 if (!fil.is_open()){ 
	 MessageBox(GetActiveWindow(), L"not file map!", L"Boulder dash", MB_ICONERROR);
	 exit(1);
 }
 string temp="";
 getline(fil,temp,'\n');
 time=string_to_int(temp);	
 getline(fil,temp,'\n');
 mario.live=string_to_int(temp);
 getline(fil,temp,'\n');
 max_level=string_to_int(temp);
 fil.close();
//	Clock clock;
 set_player(window,sprite_map,mario,TileMap,&H,&W,time,start_door);
	while (window.isOpen())
	{
		Event event;
		while (window.pollEvent(event)){
			if (event.type == Event::Closed){window.close();exit(0);}
		
		}
		
		if (button_no_press && Keyboard::isKeyPressed(Keyboard::Add )) time+=1;

		if (Keyboard::isKeyPressed(Keyboard::Subtract  )) time-=1;
		
		if (time<0)time=0;
	
		button_no_press = true;// запрешаеи нажатия двух клавиш одновременно

		if (button_no_press && Keyboard::isKeyPressed(Keyboard::Left)) {mario.dx = -16; sound_step1.play();button_no_press= false;}

		if (button_no_press && Keyboard::isKeyPressed(Keyboard::Right)){ mario.dx = 16;sound_step1.play(); button_no_press= false;}

		if (button_no_press && Keyboard::isKeyPressed(Keyboard::Up)) {mario.dy=-16;sound_step2.play(); button_no_press= false;}
		
		if (button_no_press && Keyboard::isKeyPressed(Keyboard::Down)) {mario.dy=16;sound_step2.play(); button_no_press= false;}
		
		if (mario.dx+mario.dy==0)mario.sprite.setTextureRect(IntRect(16,0,16,16));

		if (mario.rect.left>208) offsetX = mario.rect.left - 208;// установка игрока по центру
		else offsetX=0;
		
		if (mario.rect.top>123)offsetY = mario.rect.top - 123;
        else offsetY=0;
	    
			window.clear(Color(25,29,25));

		  if (pldy-mario.dy==0){rockfall=true; pldy=mario.dy;}
		  else {rockfall=false;pldy=mario.dy;}
			mario.update(time);

		show(window,sprite_map,TileMap,&H,&W,flash);
      //  kill=move_enemy(TileMap,cube,quantity_cube,cube[0].symbol,mario);
		//if(!kill) kill=move_enemy(TileMap,stars,quantity_stars,stars[0].symbol,mario);
			if (rockfall){        // пропуск одного камня 
			for ( i=H-1; i>0; i--){
		  	for ( j=W-1; j>0 ; j--) {
					if (TileMap[i][j]=='R'){  // если встретился камень
                     kill=gravity(TileMap,i,j,mario.rect.left/16,mario.rect.top/16,sound_stone_left,sound_stone,cube,quantity_cube,stars,quantity_stars);
					}
						if(kill==1)	
						{   // если камень попал по игроку
							kill=0;
							mario.diamant=0;
							int x,y;	
							for(  int c=0;c<3;c++){ 
								for ( int i_=0;i_<3;i_++){
									for (int j_=0;j_<3;j_++){  //рисуем взрыв камня

										y=i_-1+mario.rect.left/16;
										x=j_-1+mario.rect.top/16;

										if (TileMap[x][y]!='H')	TileMap[x][y] = int_to_string(c);
									}
								}
								show(window,sprite_map,TileMap,&H,&W,flash);
								window.display();
								for (int t=0;t<30;t++){Sleep(time);}
							}
							mario.live--;
							if (mario.live==0)gameover= true;
							delete_map(TileMap,&H,cube,stars,quantity_cube,quantity_stars);
							TileMap=start(number_level , &H , &W, &win );
							mario.TileMap=TileMap;
							set_player(window,sprite_map,mario,TileMap,&H,&W,time,start_door);		
							Enemy *cube= create_enemy(TileMap,H,W,&quantity_cube,'C');
							Enemy *stars= create_enemy(TileMap,H,W,&quantity_stars,'X');
						}
               
						if(kill==2)	
						{   // если камень попал по игроку
							kill=0;
			
							int x,y;	
							for(  int c=0;c<3;c++){ 
								for ( int i_=0;i_<3;i_++){
									for (int j_=0;j_<3;j_++){  //рисуем взрыв камня

										y=i_-1+mario.rect.left/16;
										x=j_-1+mario.rect.top/16;

										if (TileMap[x][y]!='H')	TileMap[x][y] = int_to_string(c);
									}
								}
								show(window,sprite_map,TileMap,&H,&W,flash);
								window.display();
								for (int t=0;t<30;t++){Sleep(time);}
							}
							mario.live--;
							if (mario.live==0)gameover= true;
							delete_map(TileMap,&H,cube,stars,quantity_cube,quantity_stars);
							TileMap=start(number_level , &H , &W, &win );
							mario.TileMap=TileMap;
							set_player(window,sprite_map,mario,TileMap,&H,&W,time,start_door);		
							Enemy *cube= create_enemy(TileMap,H,W,&quantity_cube,'C');
							Enemy *stars= create_enemy(TileMap,H,W,&quantity_stars,'X');
						}
			
			
			}
			 }            
			}
			
	
			flash.diamant_flash+=1;
			if(flash.diamant_flash>7)flash.diamant_flash=0; //меняем спрайт алмаза
			flash.cube_flash+=1;
			if(flash.cube_flash>3)flash.cube_flash=0; //меняем спрайт алмаза
			flash.star_flash+=1;
			if(flash.star_flash>3)flash.star_flash=0; //меняем спрайт алмаза
			
			
			window.draw(mario.sprite);
       
			std::ostringstream shift;    // объявили переменную
			shift << mario.diamant;
 			Font font;//шрифт 
			font.loadFromFile("Impact Regular.ttf");//передаем нашему шрифту файл шрифта
 			
			Text text1("", font,10);//создаем объект текст. закидываем в объект текст строку, шрифт, размер шрифта(в пикселях);//сам объект текст (не строка)
 			 text1.setColor(Color::White);//покрасили текст в красный. если убрать эту строку, то по умолчанию он белый
 			// text.setStyle(sf::Text::Bold | sf::Text::Underlined);//жирный и подчеркнутый текст. по умолчанию он "худой":)) и не подчеркнутый
 		
			 text1.setString(L"Собрано камней:"+shift.str());//задает строку тексту
			 text1.setPosition(0, 0);
			 window.draw(text1);
			 
			 Text text2("", font,10);
             shift.str("");
			 shift<<time;
		   	text2.setPosition(120, 0);//задаем позицию текста, центр камеры
			 text2.setString(L"замедление игры "+shift.str());
 			 window.draw(text2);//рисую этот текст
 				
			 Text text3("", font,10);
			 shift.str("");
			 shift<<mario.live;
			 text3.setPosition(250, 0);//задаем позицию текста, центр камеры
			 text3.setString(L"     жизнь "+shift.str());
			 window.draw(text3);//рисую этот текст
			 
			 Text text4("", font,10);
			 shift.str("");
			 shift<<number_level;
			 text4.setPosition(320, 0);//задаем позицию текста, центр камеры
			 text4.setString(L"уровень "+shift.str());
			 window.draw(text4);//рисую этот текст

			 window.display();
			 if (gameover){     // проигрыш
				 delete_map(TileMap,&H,cube,stars,quantity_cube,quantity_stars);
              while(1){
				 window.clear(Color(25,29,25));
				 Text text2("", font,40);
				 text2.setPosition(80, 80);//задаем позицию текста, центр камеры
				 text2.setString(" GAME  OVER ");
				 window.draw(text2);//рисую этот текст
				 while (window.pollEvent(event)){
					 if (event.type == Event::Closed){window.close();exit(0);}
				   window.display();
				   if (Keyboard::isKeyPressed(Keyboard::Escape)||Keyboard::isKeyPressed(Keyboard::Return))exit(0);
			  }
			 }
			 }
			 if(mario.diamant>=win&&flag_win==false){ //при наборе нужного количестве алмазов открываем дверь
				 flag_win=true;
				 for ( i=0; i<H; i++){
					 for ( j=0; j<W ; j++) 
					 { 
						 if (TileMap[i][j]=='E'){TileMap[i][j]='e';door.play(); }
					 }
				 }			 
			 } 
			 i = (mario.rect.top)/16;
		     j =(mario.rect.left)/16;
		   if (TileMap[i][j]=='e'){  //переход игрока на другой уровень
			   number_level++;
			   if (number_level>max_level){
				   delete_map(TileMap,&H,cube,stars,quantity_cube,quantity_stars);
				   while(1){
					   window.clear(Color(25,29,25));
					   Text text2("", font,40);
					   text2.setPosition(80, 80);//задаем позицию текста, центр камеры
					   text2.setString(" END OF GAME  ");
					   window.draw(text2);//рисую этот текст
					   while (window.pollEvent(event)){
						   if (event.type == Event::Closed){ window.close();exit(0);}
					   window.display();
					   if (Keyboard::isKeyPressed(Keyboard::Escape)||Keyboard::isKeyPressed(Keyboard::Return))exit(0);
				  
					   }
					   }  
			   }
			   mario.diamant=0;
			   flag_win=false;
			   delete_map(TileMap,&H,cube,stars,quantity_cube,quantity_stars);
			   TileMap=start(number_level, &H , &W, &win );
			   mario.TileMap=TileMap;
			   set_player(window,sprite_map,mario,TileMap,&H,&W,time,start_door);
		   }
	}	
	return 0;
}

//-------------------------------------------------------------------------------------------------------------------------------------------

int gravity(string **TileMap,int i,int j, int plx,int ply,gamesound &stone_left,gamesound &stone,Enemy *cube,int qantity_cube, Enemy *stars,int qantity_stars){

	if (TileMap[i+1][j]=='R'||TileMap[i+1][j]=='W'){
		if(TileMap[i+1][j+1]=='C'&&TileMap[i][j+1]==' '){
			TileMap[i+1][j+1]=TileMap[i][j];
			TileMap[i][j]=' ';
			return 2;}
		if((j+1==plx&&i+1==ply)&&TileMap[i][j+1]==' ')return 1;
		if(TileMap[i+1][j+1]==' '&&TileMap[i][j+1]==' '){
			//if(j+1==plx&&i+2==ply)return 1;
			TileMap[i+1][j+1]=TileMap[i][j];
			TileMap[i][j]=' ';
			stone_left.play();
			return 0;
		}
		if(TileMap[i+1][j-1]=='C'&&TileMap[i][j-1]==' '){
			TileMap[i+1][j-1]=TileMap[i][j];
			TileMap[i][j]=' ';
			return 2;}
		if((j-1==plx&&i+2==ply)&&TileMap[i][j+1]==' ')return 1;
		if(TileMap[i+1][j-1]==' '&&TileMap[i][j-1]==' '){
			TileMap[i+1][j-1]=TileMap[i][j];
			TileMap[i][j]=' ';
			stone_left.play();
			return 0;
		}
	}

if(TileMap[i+1][j]=='C'){return 2;}	
if (TileMap[i+1][j]!=' ')return 0;
if(j==plx&&i+2==ply)
{return 1;}
if(TileMap[i+2][j]=='X')return 2;
	 TileMap[i+1][j]=TileMap[i][j];
	 TileMap[i][j]=' ';
	 stone.play();
	 return 0;
}
//*************************************************************************************************************************************
int string_to_int(string s){
	int n=0;
	stringstream ss;
	ss<<s;
	ss>>n;
	return n;
}
//*************************************************************************************************************************************
string int_to_string(int n){
	string s;
	stringstream ss;
	ss<<n;
	ss >>s;
	return s;
}

//***********************************************************************************************************************************
string** start(int number_level,int *H_,int *W_, int *win_){
	
	int win;
	int H,W;
	string temp="";
	string level="level";
	level+=int_to_string(number_level);
	level+=".map";
	std::ifstream  fil(level); // (ВВЕЛИ НЕ КОРРЕКТНОЕ ИМЯ ФАЙЛА)
	if (!fil.is_open()){ // если файл не открыт
	MessageBox(GetActiveWindow(), L"not file map!", L"Boulder dash", MB_ICONERROR);
		exit(1);
	}
	getline(fil,temp,'\n');
	win=string_to_int(temp);
	getline(fil,temp,'\n');
	H=string_to_int(temp);
	getline(fil,temp,'\n');
	W=string_to_int(temp);

	string  **TileMap = new string  *[H];
	for (int i = 0; i < H; i++) {          // двумерный
		TileMap[i] = new string [W]; // массив 
	}   

	int i=0;
	temp="";
	while(i<H) {// считываем карту

		getline(fil,temp,'\n');
		if(temp.length()!=W){
		MessageBox(GetActiveWindow(), L"wrong map file!", L"Boulder dash", MB_ICONERROR);
			exit(1);
		}
		for(int j=0;j<W;j++){
			TileMap[i][j]=temp[j];
		}
		temp="";
		i++;
	}
	if (i!=H){
		MessageBox(GetActiveWindow(), L"wrong map file!", L"Boulder dash", MB_ICONERROR);
		exit(1);
	}
	fil.close(); // закрываем файл
	*win_=win;
	*H_=H;
	*W_=W;
	return TileMap;
}
//***************************************************************************************************************************************
void delete_map(string** TileMap,int *H_, Enemy *cube,  Enemy *stars,int qantity_cube,int qantity_stars){
	int H=*H_;
	for (int i = 0; i < H; i++) {          // двумерный
		delete [] TileMap[i];
	}  
	delete[]TileMap;
	if(qantity_cube!=0)delete[] cube;
	else cube=nullptr;
	if (qantity_stars!=0)delete[] stars;
	else stars=nullptr;
}
//*************************************************************************************************************************************************
void show(RenderWindow& window, Sprite & sprite,string** TileMap, int *H,int *W, Flash flash){
	window.clear(Color(25,29,25));
	for (int i=0; i<*H; i++)
		for (int j=0; j<*W ; j++) 
		{ 
			if (TileMap[i][j]=='W')    sprite.setTextureRect(IntRect(32,48,16,16));  

			if (TileMap[i][j]=='D')  sprite.setTextureRect(IntRect(flash.diamant_flash*16,128,16,16));     

			if (TileMap[i][j]=='H')    sprite.setTextureRect(IntRect(0,48,16,16));

			if (TileMap[i][j]=='-')    sprite.setTextureRect(IntRect(64,48,16,16));

			if (TileMap[i][j]=='R')    sprite.setTextureRect(IntRect(80,48,16,16));

		    if (TileMap[i][j]=='0')    sprite.setTextureRect(IntRect(112,96,16,16));

			if (TileMap[i][j]=='1')    sprite.setTextureRect(IntRect(112,80,16,16));
		
			if (TileMap[i][j]=='2')    sprite.setTextureRect(IntRect(112,64,16,16));

			if (TileMap[i][j]=='S')    sprite.setTextureRect(IntRect(0,48,16,16));

			if (TileMap[i][j]=='s')   sprite.setTextureRect(IntRect(16,48,16,16));

			if (TileMap[i][j]=='e')   sprite.setTextureRect(IntRect(16,48,16,16));

			if (TileMap[i][j]=='C')    sprite.setTextureRect(IntRect(80,64+(16*flash.cube_flash),16,16));

			if (TileMap[i][j]=='X')    sprite.setTextureRect(IntRect(96,64+(16*flash.star_flash),16,16));

			if (TileMap[i][j]==' '){continue;}

			sprite.setPosition(j*16-offsetX,i*16-offsetY ) ; 
			window.draw(sprite);
	
		}
		//window.display();

}
//*************************************************************************************************************************************
void set_player(RenderWindow& window,Sprite &sprite, PLAYER& player,string ** TileMap,int *H, int *W,int time, gamesound & sound){
	
	Flash f;
	int x=1,y=1;
	for (int i=0; i<*H; i++){
		for (int j=0; j<*W ; j++) 
		{ 
			if (TileMap[i][j]=='S'){TileMap[i][j]=' ';y=j;x=i;}

		}
	}
		player.rect=FloatRect(y*16,x*16,16,16);
		if (player.rect.left>208) offsetX = player.rect.left - 208;// установка игрока по центру
     else offsetX=0;
		if (player.rect.top>123)offsetY = player.rect.top - 123;
	   else offsetY=0;
		player.update(time);
		for (int c =0;c<2;c++){
		TileMap[x][y]='S';
		show(window,sprite,TileMap,H,W,f);
        window.display();
		 sound.play();
		for (int t=0;t<30;t++){Sleep(time);}
		TileMap[x][y]='s';
		show(window,sprite,TileMap,H,W,f);
		window.display();
        for (int t=0;t<30;t++){Sleep(time);}
		sound.play();
		}
	 
}
//************************************************************************************************************************************
Enemy* create_enemy(string** Tilemap,int H,int W, int *quantity,char name_enemy){
		int quantity_=0;
	for (int i=0; i<H; i++){
		for (int j=0; j<W ; j++)
		{
		if (Tilemap[i][j]==name_enemy)
		{quantity_++;}
		}
	}
		

		*quantity=quantity_;
	if (quantity_==0){
		  Enemy*temp;
		


		return temp;
	}

    Enemy*temp= new Enemy[quantity_];
	int c=0;
	for (int i=0; i<H; i++)
		for (int j=0; j<W ; j++){
         if (Tilemap[i][j]==name_enemy){
			 temp[c].x=j;temp[c].y=i;temp[c].symbol=name_enemy;c++; }
	
		}
		return temp;
}
//************************************************************************************************************************************
bool move_enemy(string** TileMap,Enemy* enemy,int quantity,char name_enemy,PLAYER player){
	
	if(quantity==0)return false;
	int player_x=player.rect.left/16;
	int player_y=player.rect.top/16;

		for (int c=0;c<quantity;c++){
	//cout <<TileMap[7][23]<<endl;
	 
			if((enemy[c].y==player_y&&enemy[c].x-1==player_x)||(enemy[c].y+1==player_y&&enemy[c].x==player_x)||(enemy[c].y==player_y&&enemy[c].x+1==player_x)||(enemy[c].y-1==player_y&&enemy[c].x==player_x))return true;
			switch(enemy[c].step){
			
		case 1:   
			
				 if(TileMap[enemy[c].y-1][enemy[c].x]==' '){
			       TileMap[enemy[c].y-1][enemy[c].x]=name_enemy;
			       TileMap[enemy[c].y][enemy[c].x]=' ';
			        enemy[c].y--;
				   enemy[c].step=4;
				   }
				   else 
					if(TileMap[enemy[c].y][enemy[c].x-1]==' '){
					TileMap[enemy[c].y][enemy[c].x-1]=name_enemy;
					TileMap[enemy[c].y][enemy[c].x]=' ';
					enemy[c].x--;
				}
	   
				else enemy[c].step=2;
				break;	
		case 2:		
		
			       if(TileMap[enemy[c].y][enemy[c].x-1]==' '){
			       TileMap[enemy[c].y][enemy[c].x-1]=name_enemy;
			       TileMap[enemy[c].y][enemy[c].x]=' ';
			        enemy[c].x--;
                    enemy[c].step=1;
				   }
			       else if(TileMap[enemy[c].y+1][enemy[c].x]==' '){
					TileMap[enemy[c].y+1][enemy[c].x]=name_enemy;
					TileMap[enemy[c].y][enemy[c].x]=' ';
					enemy[c].y++;
				}
				else enemy[c].step=3;
					break;	
		case 3:	
	
			     if(TileMap[enemy[c].y+1][enemy[c].x]==' '){
			       TileMap[enemy[c].y+1][enemy[c].x]='C';
			       TileMap[enemy[c].y][enemy[c].x]=' ';
			        enemy[c].y++;
					 enemy[c].step=2;
				 }
				 else  if(TileMap[enemy[c].y][enemy[c].x+1]==' '){
					TileMap[enemy[c].y][enemy[c].x+1]=name_enemy;
					TileMap[enemy[c].y][enemy[c].x]=' ';
					enemy[c].x++;
			
				}
				else enemy[c].step=4;
					break;
		case 4:
	
			       if(TileMap[enemy[c].y][enemy[c].x+1]==' '){
			       TileMap[enemy[c].y][enemy[c].x+1]=name_enemy;
			       TileMap[enemy[c].y][enemy[c].x]=' ';
			        enemy[c].x++;
					enemy[c].step=3;
				   }
				 
			else if(TileMap[enemy[c].y-1][enemy[c].x]==' '){
					TileMap[enemy[c].y-1][enemy[c].x]=name_enemy;
					TileMap[enemy[c].y][enemy[c].x]=' ';
					enemy[c].y--;	
				}
				 else  enemy[c].step=1;
				 	break;

			}
		}
return false;
}